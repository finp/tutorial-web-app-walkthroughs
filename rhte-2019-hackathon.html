<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>RHTE 2019 RHMI Hackathon</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="node_modules/reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="node_modules/reveal.js/css/theme/black.css" id="theme"><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link href="node_modules/reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "node_modules/reveal.js/css/print/pdf.css" : "node_modules/reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="node_modules/reveal.js/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>RHTE 2019 RHMI Hackathon</h1><div class="preamble"><div class="paragraph"><p>Welcome to the RHTE 2019 Red Hat Managed Integration Hackathon!</p></div>
<div class="paragraph"><p>Red Hat Managed Integration (RHMI) delivers cloud-based agile integration services hosted on OpenShift Dedicated (OSD). Using RHMI we can create consistent, immediately available, managed environments so that development teams can more easily build enterprise applications on OpenShift.
These environments accelerate engagement timelines, reduce operational risk and cost, and address the needs of the evolving enterprise integration market.</p></div>
<div class="paragraph"><p>In this hackathon youâ€™re tasked with building out a real-time IoT traffic and parking meter management solution for the city of Los Angeles.
Attendees may tackle this hackathon alone or pair up with a colleague in teams of 2 to complete the following tasks:</p></div>
<div class="ulist"><ul><li><p>Data ingestion of real time traffic and parking meter data from AMQ Streams into a Postgres Database using Red Hat Fuse Online</p></li><li><p>Definition of an OpenAPI compatible API Spec using Apicurio</p></li><li><p>Implementation of this API using your choice of Runtime technologies - Fuse, Spring Boot, Vert.x or Node.js</p></li><li><p>Protection of the API using 3scale API Management</p></li><li><p>Visualisation of the data from the API via a front end web app based on React.js and Patternfly.js</p></li></ul></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>To get you started, you will be provided with the following infrastructure:</p></div>
<div class="ulist"><ul><li><p>An AMQ Streams instance with 2 topics - junctions and meter. These topics will be connected to a live stream of IoT data which needs to be ingested</p></li><li><p>A Postgres server with two databases:</p><div class="ulist"><ul><li><p>A pre populated Lookup database containing reference data which maps incoming Ids for traffic junctions and parking meters to their corresponding names and geo locations</p></li><li><p>An empty database, with pre defined schemas for storing the live IoT traffic and sensor data</p></li></ul></div></li><li><p>Access to the Apicurio API designer tool for creating the OpenAPI Spec compatible API definition</p></li><li><p>Outline reference implementations of the API Server in Fuse, Spring Boot, Vert.x and Node.js which will have a single API definition implemented and connectivity to Postgres pre-configured</p></li><li><p>Access to 3scale API Management service for protecting your API</p></li><li><p>Outline reference implementations of the front end web app with a single API call implemented</p></li></ul></div>
<div class="ulist"><div class="title">Prerequisites</div><ul><li><p><code>oc</code> on your local machine</p></li><li><p>a GitHub account (<a href="https://github.com/join" target="_blank">github.com/join</a>)</p></li></ul></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The architecture diagram below provides an overview of the complete solution.</p></div>
<div class="imageblock integr8ly-img-responsive" style=""><img src="images/arch.png" alt="integration"></div>
<div class="sidebarblock"><div class="content"><div class="title">Red Hat OpenShift</div><div class="ulist"><ul><li><p><a href="{openshift-host}/console" target="_blank">Console</a></p></li><li><p><a href="https://help.openshift.com/" target="_blank">Openshift Online Help Center</a></p></li><li><p><a href="https://blog.openshift.com/" target="_blank">Openshift Blog</a></p></li></ul></div></div></div>
<div class="sidebarblock"><div class="content"><div class="title">Fuse Online</div><div class="ulist"><ul><li><p><a href="{fuse-url}" target="_blank">Console</a></p></li><li><p><a href="https://access.redhat.com/documentation/en-us/red_hat_fuse/7.4/html/integrating_applications_with_fuse_online/index" target="_blank">Documentation</a></p></li><li><p><a href="https://www.redhat.com/en/technologies/jboss-middleware/fuse-online" target="_blank">Overview</a></p></li></ul></div></div></div>
<div class="sidebarblock"><div class="content"><div class="title">Apicurito</div><div class="ulist"><ul><li><p><a href="{apicurio-url}" target="_blank">Console</a></p></li></ul></div></div></div>
<div class="sidebarblock"><div class="content"><div class="title">3Scale</div><div class="ulist"><ul><li><p><a href="https://{user-username}-admin.{openshift-app-host}" target="_blank">Console</a></p></li><li><p><a href="https://access.redhat.com/documentation/en-us/red_hat_3scale_api_management/2.6/" target="_blank">Documentation</a></p></li><li><p><a href="https://www.redhat.com/en/technologies/jboss-middleware/3scale" target="_blank">Overview</a></p></li></ul></div></div></div>
<div class="sidebarblock"><div class="content"><div class="title">CodeReady Workspaces</div><div class="ulist"><ul><li><p><a href="{che-url}" target="_blank">Console</a></p></li><li><p><a href="https://developers.redhat.com/products/codeready-workspaces/overview/" target="_blank">Overview</a></p></li><li><p><a href="https://access.redhat.com/documentation/en-us/red_hat_codeready_workspaces/1.2/" target="_blank">Documentation</a></p></li></ul></div></div></div></div></section>
<section><section id="_data_ingestion_from_amq_streams_to_postgres_using_fuse_online"><h2>Data Ingestion from AMQ Streams to Postgres using Fuse Online</h2><div class="paragraph"><p>Fuse Online is an enterprise integration platform that provides connectors for many services, such as AMQ Streams and Postgres.
In this section we will create two connections - one to AMQ Streams and one to Postgres.
We will then create an integration that uses these two connections and translates the incoming data from AMQ streams into database <strong>INSERT</strong> statements on Postgres.</p></div></section><section id="_creating_the_amq_streams_connector"><h2>Creating the AMQ Streams Connector</h2><div class="olist arabic"><ol class="arabic"><li><p>Log in to the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console.</p></li><li><p>Select <strong>Connections</strong> from the left hand menu.</p></li><li><p>Select the <strong>Create Connection</strong> button to start the <strong>Create Connection</strong> wizard.</p></li><li><p>When prompted with <strong>Select Connector</strong>, select <strong>Kafka Message Broker</strong>.</p></li><li><p>When prompted with <strong>Configure connection</strong>:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Enter the following in the <strong>Kafka Broker URIs</strong> field:</p><pre class="highlight listingblock"><code>integreatly-cluster-kafka-brokers.amq-streams.svc:9092</code></pre></li><li><p>Click the <strong>Validate</strong> button to ensure the connection to AMQ Streams is configured correctly.</p></li><li><p>You should see the message <code>Kafka Message Broker has been successfully validated</code>.</p></li><li><p>Click Next to move onto the <strong>Name connection</strong> step</p></li></ol></div></li><li><p>When prompted with <strong>Name connection</strong>:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Enter the following in the <strong>Name</strong> field:</p><pre class="highlight listingblock"><code>AMQ Streams Message Broker</code></pre></li></ol></div></li><li><p>Click <strong>Save</strong>.</p></li></ol></div>
<div class="paragraph"><p>Is a connection named <strong>AMQ Streams Message Broker</strong> displayed on the <strong>Connections</strong> screen of the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console?</p></div>
<div class="paragraph"><p>Verify that you followed each step in the procedure above.  If you are still having issues, contact your administrator.</p></div></section><section id="_creating_the_postgres_connector"><h2>Creating the Postgres Connector</h2><div class="paragraph"><p>To allow Fuse Online to write data consumed from AMQ Streams to Postgres, we need to create a new Database connection in Red Hat Fuse Online.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Log in to the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console.</p></li><li><p>Select <strong>Connections</strong> from the left hand menu.</p></li><li><p>Select the <strong>Create Connection</strong> button to start the <strong>Create Connection</strong> wizard.</p></li><li><p>Select <strong>Database</strong> to configure a <strong>Postgres</strong> connection.</p></li><li><p>Enter the connection URL:</p><pre class="highlight listingblock"><code>jdbc:postgresql://postgresql.city-of-losangeles.svc:5432/city-info</code></pre></li><li><p>Enter the Username:</p><pre class="highlight listingblock"><code>{user-sanitized-username}</code></pre></li><li><p>Enter the password:</p><pre class="highlight listingblock"><code>Password1</code></pre></li><li><p>Leave the Schema field blank for now.</p></li><li><p>Select the <strong>Validate</strong> button to check that the values are valid.</p></li><li><p>Click <strong>Next</strong> and enter a name for the connection, for example:</p><pre class="highlight listingblock"><code>City Postgres</code></pre></li><li><p>Click <strong>Save</strong>.</p></li></ol></div>
<div class="paragraph"><p>Is the new Postgres connection displayed on the <strong>Connections</strong> screen of the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console?</p></div>
<div class="paragraph"><p>Verify that you followed each step in the procedure above.  If you are still having issues, contact your administrator.</p></div></section><section id="_creating_the_integration_between_amq_streams_and_postgres_for_traffic_data"><h2>Creating the integration between AMQ Streams and Postgres for traffic data</h2><div class="olist arabic"><ol class="arabic"><li><p>Log in to the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console.</p></li><li><p>Select <strong>Integrations</strong> from the left hand menu.</p></li><li><p>Select the <strong>Create Integration</strong> button to start the <strong>Create Integration</strong> wizard.</p></li><li><p>Choose <strong>AMQ Streams Message Broker</strong> as the connection that starts the integration.</p></li><li><p>When prompted to <strong>Choose an Action</strong>, select <strong>Subscribe</strong>.</p></li><li><p>When prompted to select a <strong>Topic Name</strong>, select <strong>junctions</strong>:</p></li><li><p>When prompted to <strong>Specify Output Data Type</strong>:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Select <strong>JSON Schema</strong> as the type.</p></li><li><p>Enter the following in the <strong>Definition</strong> field:</p><pre class="highlight listingblock"><code>{
	"$schema": "http://json-schema.org/draft-04/schema#",
	"type": "object",
	"properties": {
		"junctionId" : { "type": "number" },
		"timestamp" : { "type": "number" },
		"counts" : {
			"type" : "object",
			"properties" : {
				"ns": { "type": "number" },
				"ew": { "type": "number" }
			}
		}
	}
}</code></pre></li><li><p>Enter <strong>junction_data</strong> in the <strong>Data Type Name</strong> field.</p></li><li><p>Click <strong>Next</strong>.</p></li></ol></div></li><li><p>Choose <strong>City Postgres</strong> as the <strong>Finish Connection</strong>.</p></li><li><p>When prompted to <strong>Choose an Action</strong>, select <strong>Invoke SQL</strong>.</p></li><li><p>When prompted with <strong>Configure the action</strong>, enter the following:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Enter the following in the <strong>SQL statements</strong> field:</p><pre class="highlight listingblock"><code>INSERT INTO junction_status_{user-sanitized-username} (junction_id, timestamp, count_ns, count_ew)
VALUES (:#junction_id, to_timestamp(:#timestamp), :#count_ns, :#count_ew);</code></pre></li><li><p>Leave <strong>Batch update</strong> set to <strong>No</strong></p></li><li><p>Click <strong>Next</strong></p></li></ol></div></li><li><p>When prompted to <strong>Add to Integration</strong>, click on the blue <strong>+</strong> icon between the <strong>Subscribe</strong> step and the <strong>Invoke SQL</strong> step.</p></li><li><p>Select <strong>Data Mapper</strong> to map the source fields in the AMQ Streams JSON schema to the placeholder parameters in the SQL Statement:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Click and drag <strong>junctionid</strong> from the Source coulmn to <strong>junction_id</strong> in the <strong>Target</strong> column.</p></li><li><p>Click and drag <strong>timestamp</strong> from the Source coulmn to <strong>timestamp</strong> in the <strong>Target</strong> column.</p></li><li><p>Expand the <strong>counts</strong> object to expose the two child objects - <strong>ew</strong> and <strong>ns</strong>.</p></li><li><p>Click and drag <strong>ew</strong> from the Source coulmn to <strong>count_ew</strong> in the <strong>Target</strong> column.</p></li><li><p>Click and drag <strong>ns</strong> from the Source coulmn to <strong>count_ns</strong> in the <strong>Target</strong> column.</p></li><li><p>Click <strong>Done</strong> to navigate back to the <strong>Integration</strong> screen.</p></li></ol></div></li><li><p>Click <strong>Publish</strong>.</p></li><li><p>When prompted, enter a name, for example:</p><pre class="highlight listingblock"><code>IoT Junction Data Ingestion</code></pre></li><li><p>Click <strong>Save and publish</strong>.</p></li><li><p>Monitor the <strong>Integration Summary</strong> dashboard until a green check mark is displayed beside the new integration.
The integration may take a number of minutes to complete building.</p></li></ol></div>
<div class="paragraph"><p>Is the integration displayed as <strong>Running</strong> on the <strong>Integration</strong> screen of the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console?</p></div>
<div class="sidebarblock"><div class="content"><div class="olist arabic"><ol class="arabic"><li><p>Wait for the integration to appear. This can take several minutes.</p></li><li><p>Verify that you followed each step in the procedure above.  If you are still having issues, contact your administrator.</p></li></ol></div></div></div></section><section id="_creating_the_integration_between_amq_streams_and_postgres_for_parking_meter_data"><h2>Creating the integration between AMQ Streams and Postgres for parking meter data</h2><div class="olist arabic"><ol class="arabic"><li><p>Repeat the steps above for the <strong>IoT Junction Data Ingestion</strong> integration, with the following changes:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>When prompted for a <strong>Topic Name</strong>, enter:</p><pre class="highlight listingblock"><code>meter</code></pre></li><li><p>Enter the following in the JSON Schema <strong>Definition</strong> field:</p><pre class="highlight listingblock"><code>{
	"$schema": "http://json-schema.org/draft-04/schema#",
	"type": "object",
	"properties": {
		"meterId" : { "type": "number" },
		"timestamp" : { "type": "number" },
		"status" : { "type": "string" }
	}
}</code></pre></li><li><p>When configuring the SQL Statement, enter the following:</p><pre class="highlight listingblock"><code>INSERT INTO meter_status_{user-sanitized-username} (meter_id, status_text, timestamp)
 VALUES (:#meter_id, :#status_text, to_timestamp(:#timestamp));</code></pre></li><li><p>When adding the <strong>Data Mapper</strong> map the 3 fields as follows:</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>meterId &#8658; meter_id</p></li><li><p>timestamp &#8658; timestamp</p></li><li><p>status &#8658; status_text</p></li></ol></div></li></ol></div></li></ol></div>
<div class="paragraph"><p>Is the integration displayed as <strong>Running</strong> on the <strong>Integration</strong> screen of the <a href="{fuse-url}" target="_blank">Red Hat Fuse Online</a> console?</p></div>
<div class="sidebarblock"><div class="content"><div class="olist arabic"><ol class="arabic"><li><p>Wait for the integration to appear. This can take several minutes.</p></li><li><p>Verify that you followed each step in the procedure above.  If you are still having issues, contact your administrator.</p></li></ol></div></div></div>
<div class="sidebarblock"><div class="content"><div class="title">Task Resources</div><div class="ulist"><ul><li><p><a href="https://access.redhat.com/documentation/en-us/red_hat_fuse/{fuse-version}/html-single/integrating_applications_with_fuse_online/creating-integrations_ug#creating-integrations_ug" target="_blank">Creating integrations</a></p></li></ul></div></div></div></section></section>
<section><section id="_api_definition_using_apicurio"><h2>API Definition using Apicurio</h2><div class="paragraph"><p>Apicurito is the Red Hat API Designer tool that provides the ability to create <strong>OpenAPI Specification</strong> compatible API definitions.
The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection.</p></div><div class="paragraph"><p>When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.
An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.
For more information on the <strong>OpenAPI Specification</strong> see the <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md" target="_blank">Open API Specification</a> on GitHub</p></div><div class="paragraph"><p>In this section we will use the Red Hat API designer to create an OpenAPI Specification which will then be used to bootstrap the development of our API Server.
The APIs created should combine data from the provided Lookup Tables in Postgres - <strong>junction_info</strong> and <strong>meter_info</strong> - with the data from the live junction and meter tables which is being injested from AMQ Streams.</p></div></section><section id="_api_data_types"><h2>API Data Types</h2><div class="paragraph"><p>You will need to create at least two main API Data Types - <strong>Junction</strong> and <strong>Meter</strong>.
These Data Types form the basis for the APIs which will be created to act upon the data types.
For more information on <strong>Data Types</strong> see the <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#dataTypes">Open API Spec Data Types Documentation</a></p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Log in to the <a href="{apicurio-url}" target="_blank">Red Hat API Designer</a> console.</p></li><li><p>Click the <strong>New API</strong> Button</p></li><li><p>Click the <strong>Add a data type</strong> link on the left of the screen under the <strong>Data Types</strong> heading</p></li><li><p>Enter the value of <code>Meter</code> in the <strong>Name</strong> field</p></li><li><p>Enter the following vale for <strong>JSON Example</strong></p><pre class="highlight listingblock"><code>{
  "meter_id": 1,
  "last_updated": "2019-10-15T20:12:32Z",
  "address": "1301 N LA BREA AVE",
  "latitude": 34.095452,
  "longitude": -118.344219,
  "status": "available"
}</code></pre></li><li><p>Click the <strong>REST Resource</strong> box to create default REST resources for the Meter data type</p></li><li><p>Click <strong>Save</strong></p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Repeat the above steps to add a Data Type for <strong>Junction</strong>, providing the following value for the <strong>JSON Example</strong> field.</p></div>
<pre class="highlight listingblock"><code>{
  "id": 1,
  "junction_name": "CANOGA AV AT VANOWEN ST",
  "latitude": 34.18834537329447,
  "longitude": -118.59747110546994,
  "east_west_count" : 10,
  "north_south_count" : 8
}</code></pre></section><section id="_api_paths"><h2>API Paths</h2><div class="paragraph"><p>Default API Paths have automatically been created when creating the <strong>Meter</strong> and <strong>Junction</strong> data types, by clicking the <strong>REST Resource</strong> box during the data type creation.
This will provide default implementations for <strong>GET</strong> and <strong>POST</strong> paths, both for listing all <strong>Meter</strong> and <strong>Junction</strong> data types as well as getting specific <strong>Meter</strong> and <strong>Junction</strong> data types by id.
The API should only support read operations, which means that the <strong>POST</strong>, <strong>PUT</strong> and <strong>DELETE</strong> methods should be removed.</p></div>
<div class="paragraph"><p>The <strong>GET</strong> endpoint for the <strong>Meter</strong> data type should be extended to support an optional query paramter called <strong>status</strong> which can be used to return a filtered list of <strong>Meter</strong> objects that match the specific status.
The supported values for status that will need to be catered for during API implementation are "available", "occupied", "unknown", or "out-of-service".</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Select the <strong>/meters</strong> path.</p></li><li><p>Click on the <strong>GET</strong> operation.</p></li><li><p>Click the <strong>+</strong> symbol to the right of <strong>QUERY PARAMETERS</strong></p></li><li><p>Enter the following value for <strong>Name</strong>: <code>status</code></p></li><li><p>Enter the following value for <strong>Description</strong>: <code>Filter list of returned meters by status. Supported values for status are are "available", "occupied", "unknown", or "out-of-service".</code></p></li><li><p>Under Type Information, leave the parameter as <strong>Not Required</strong> and select <code>String</code> from the <strong>type</strong> dropdown</p></li><li><p>Click Save.</p></li></ol></div></section><section id="_download_the_completed_openapi_specification"><h2>Download the completed OpenAPI Specification</h2><div class="paragraph"><p>Once you have fully defined the API specification, click <strong>Generate</strong> &#8658; <strong>Fuse Camel Project</strong>
You should also download the specification in either JSON or YAML format for use in the next section, if you wish to implement the API in a technology other than <strong>Fuse Camel</strong>.</p></div></section></section>
<section><section id="_api_implementation_using_camel_spring_boot_or_node_js"><h2>API Implementation using Camel + Spring Boot or Node.js</h2></section><section id="_accessing_the_database_from_your_local_environment"><h2>Accessing the database from your local environment</h2><div class="paragraph"><p>You have been given access to a Postgres database that contains lookup and live data for the traffic junctions and parking meters.
This is the same database that you used during the Fuse Online Integration tasks when ingesting data from AMQ Streams.
To facilitate rapid development localy, you need to connect to this Postgres instance which is running on OpenShift.
To do this, you create a port forward from your local workstation to the Postgres pod running in OpenShift.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Log into OpenShift from the command line:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Open the <a href="{openshift-host}/console">OpenShift Console</a></p></li><li><p>Click on your username and choose <strong>Copy Login Command</strong>.</p></li><li><p>Paste the clipboard into your terminal.</p></li></ol></div></li><li><p>Get the name of the Postgres pod by running the following command:</p><pre class="highlight listingblock"><code>export POSTGRES_POD_NAME=$(oc get pods -n city-of-losangeles | grep postgresql | awk '{print $1}')</code></pre></li><li><p>Create a port forward to the Postgres pod:</p><pre class="highlight listingblock"><code>oc port-forward $POSTGRES_POD_NAME 5432:5432 -n city-of-losangeles</code></pre></li><li><p>This should result in output similar to this:</p><pre class="highlight listingblock"><code>Forwarding from 127.0.0.1:5432 -&gt; 5432
Forwarding from [::1]:5432 -&gt; 5432</code></pre></li><li><p>You will need to leave this terminal window running to keep the port forwarding active.</p></li><li><p>If you find that the port forwarding stops working after some time, simply <code>^C</code> to cancel the port forward session and re-run the <code>oc get pods</code> and <code>oc port forward</code> commands.</p></li></ol></div>
<div class="paragraph"><p></p></div></section><section id="_connecting_to_postgres"><h2>Connecting to Postgres</h2><div class="paragraph"><p>When implementing your API, you will need to use the following details to connect your API Server to your Postgres DB:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Username: <code>{user-sanitized-username}</code></p></li><li><p>Password: <code>Password1</code></p></li><li><p>Hostname: <code>postgresql.city-of-losangeles.svc</code></p></li><li><p>Database: <code>city-info</code></p></li><li><p>Port: <code>5432</code></p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>This information should ideally be provided to your API server via a config map, backed by a secret in OpenShift.</p></div>
<div class="paragraph"><p><strong>Note</strong>: for local development, with port forwarding active, your database hostname will be <code>localhost</code>.</p></div></section><section id="_database_table_schemas"><h2>Database Table Schemas</h2><div class="paragraph"><p>The schemas for each of the available database table are provided below.
These should be used as a reference to better understand the underlying data storage layout when implementing the APIs.</p></div>
<div class="paragraph"><p><strong>meter_info</strong></p></div>
<div class="paragraph"><p>This table stores the lookup data for parking meters.</p></div>
<pre class="highlight listingblock"><code>  Column   |  Type
-----------+---------
 id        | integer
 address   | text
 latitude  | real
 longitude | real</code></pre>
<div class="paragraph"><p><strong>junction_info</strong></p></div>
<div class="paragraph"><p>This table stores the lookup data for junctions.</p></div>
<pre class="highlight listingblock"><code>    Column     |  Type
---------------+---------
 id            | integer
 junction_name | text
 latitude      | real
 longitude     | real</code></pre>
<div class="paragraph"><p><strong>meter_status_{user-sanitized-username}</strong></p></div>
<div class="paragraph"><p>This table stores the live information on meter status.</p></div>
<pre class="highlight listingblock"><code>   Column    |  Type
-------------+---------
 id          | integer
 meter_id    | integer
 status_text | text</code></pre>
<div class="paragraph"><p><strong>junction_status_{user-sanitized-username}</strong></p></div>
<div class="paragraph"><p>This table stores the live information on junction traffic flow.</p></div>
<pre class="highlight listingblock"><code>    Column   |  Type
-------------+---------
 id          | integer
 junction_id | integer
 count_ns    | integer
 count_ew    | integer</code></pre>
<div class="paragraph"><p></p></div></section><section id="_camel_spring_boot"><h2>Camel + Spring Boot</h2><div class="paragraph"><p>You can follow this section to start building the Traffic and Parking Meters API using Camel &amp; Spring Boot.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Sign into your GitHub account.</p></li><li><p>Open the <a href="https://github.com/hguerrero/rhte-2019-hackathon-on-rhmi-fuse-camel-project" target="_blank">Camel / Spring Boot Template</a> and click the <strong>Fork</strong> button.</p></li><li><p>Clone the template locally via <code>git clone <a href="https://github.com/YOUR_USERNAME/rhte-2019-hackathon-on-rhmi-fuse-camel-project" class="bare">https://github.com/YOUR_USERNAME/rhte-2019-hackathon-on-rhmi-fuse-camel-project</a></code>.</p></li><li><p>Set your database connection parameters in <code>src/main/resources/application.yml</code></p></li><li><p>Build, run and test using your standard Java development flow.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<h3>Running Locally</h3><div class="literalblock"><div class="content"><pre>mvn spring-boot:run</pre></div></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Getting the API docs:</p></div>
<div class="literalblock"><div class="content"><pre>curl http://localhost:8080/openapi.json</pre></div></div>
<div class="paragraph"><p></p></div>
<h3>Running on OpenShift</h3><div class="olist arabic"><ol class="arabic"><li><p>Login into openshift using <code>oc login</code>, you can copy the token command from the <a href="{openshift-host}/console" target="_blank">OpenShift Console</a></p></li><li><p>Switch to your project or create a new one.</p></li><li><p>Deploy the project to OpenShift</p><div class="literalblock"><div class="content"><pre>mvn fabric8:deploy</pre></div></div></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>If you are using the template project the <code>/meters</code> API path is getting the information from the database. The rest of the services are using the default HTTP 501 <em>Not Implemented</em> result. You will need to change them and fulfill the rest of the implementation.  This implementation in Red Hat Fuse is left as a task for you.</p></div></section><section id="_node_js"><h2>Node.js</h2><div class="paragraph"><p>You can follow this section to start building the Traffic and Parking Meters API using Node.js.
You will need Node.js 10 or later installed locally, or alternatively you can use <a href="{che-url}" target="_blank">CodeReady Workspaces</a> for development since it includes a Node.js 10 stack.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="ulist"><ul><li><p>When developing locally, it&#8217;s recommended to use <a href="https://github.com/nvm-sh/nvm" target="_blank">github.com/nvm</a> to install Node.js/</p></li><li><p>After running the nvm install command, copy the output into your <code>.bashrc</code> or similar.</p></li><li><p>Open a new terminal and type <code>nvm install 10 &amp;&amp; nvm use 10</code> to install and enable Node.js 10.x.</p></li></ul></div></td></tr></table></div>
<h3>Fork &amp; Setup the Template</h3><div class="olist arabic"><ol class="arabic"><li><p>Create a GitHub account at <a href="https://github.com/join" target="_blank">github.com/join</a>, if you don&#8217;t already have one.</p></li><li><p>Sign into your GitHub account.</p></li><li><p>Open the <a href="https://github.com/evanshortiss/rhte-2019-hackathon-on-rhmi-nodejs-api-server-template" target="_blank">Node.js Template</a> and click the <strong>Fork</strong> button.</p></li><li><p>Clone the template locally via <code>git clone <a href="https://github.com/YOUR_USERNAME/rhte-2019-hackathon-on-rhmi-nodejs-api-server-template" class="bare">https://github.com/YOUR_USERNAME/rhte-2019-hackathon-on-rhmi-nodejs-api-server-template</a></code>.</p></li><li><p>Install the dependencies by running <code>npm install</code> in the cloned directory.</p></li><li><p>Copy a JSON format version of your OpenAPI Spec into the cloned folder, and rename it <code>openapi-spec.json</code>.</p></li><li><p>Run the development server by issuing the <code>npm run start-dev</code> command.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The Node.js server should have printed a <code>server listening on port 8080</code> message and accessing <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> should render API Docs from your OpenAPI Spec JSON file.</p></div>
<div class="paragraph"><p></p></div>
<h3>Implement an API Endpoint</h3><div class="olist arabic"><ol class="arabic"><li><p>Open the <em>src/db.ts</em> file and add a default value for the <code>PG_CONNECTION_STRING</code> environment variable:</p><pre class="highlight listingblock"><code>const connectionString = env
  .get(
    'PG_CONNECTION_STRING',
    'postgresql://{user-sanitized-username}:Password1@localhost:5432/city-info'
  )
  .asUrlString();</code></pre></li><li><p>Open the <em>src/routes/junctions.ts</em> file.</p></li><li><p>Add the following import statement: <code>import { query } from '../db';</code></p></li><li><p>Add the following type definition and update the route code as shown. This will return all junctions, and also provide intellisense for the returned database rows thanks to the <code>JunctionObject</code> definition.</p><pre class="highlight listingblock"><code>type JunctionObject = {
  junction_id: number,
  count_ns: number,
  count_ew: number,
  last_updated: string,
  longitude: number,
  latitude: number
};

junctionsRoute.get('/', async (req, res) =&gt; {
  const result = await query&lt;JunctionObject&gt;('SELECT * FROM junction_info;')

  res.json(result.rows)
})</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="ulist"><ul><li><p>This SQL query simply returns all Junctions without their latest status, i.e the <strong>last_updated</strong>, <strong>count_ns</strong>, and <strong>count_ew</strong> fields are missing.</p></li><li><p>The JunctionObject defined above represents what your final SQL query should return for the <strong>/junctions</strong> endpoint. Hint: you&#8217;ll need an <strong>INNER JOIN</strong> and perhaps a subquery too.</p></li><li><p>Use this as a template to build out the rest of your API endpoints and SQL queries.</p></li></ul></div></td></tr></table></div></li></ol></div>
<div class="paragraph"><p>You can test that this query is working as follows:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Start your server locally with <code>npm run start-dev</code></p></li><li><p>Navigating to your <a href="http://localhost:8080" target="_blank">API Server</a></p></li><li><p>Expand the <code>/junctions</code> API route</p></li><li><p>Click <code>Try it out</code></p></li><li><p>Click the blue <code>Execute</code> button that has been displayed</p></li><li><p>You should see a list of junctions returned.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<h3>Deploy on OpenShift</h3><div class="paragraph"><p>You&#8217;re now ready to deploy this application on OpenShift.
To deploy your code on the RHMI Cluster, follow the steps below:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Run <code>oc login {openshift-host}</code>, and enter your username and password when prompted.</p></li><li><p>Run <code>oc project {walkthrough-namespace}</code> to switch the <code>oc</code> context to your hackathon project/namespace.</p></li><li><p>Run <code>npm run nodeshift</code> to deploy your Node.js application.</p></li><li><p>Wait until the Nodeshift process completes.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>You will need to create an environment variable for the <code>PG_CONNECTION_STRING</code> parameter used in the code block above.
Without an environment variable, the API server will try to use the <code>localhost</code> default that was defined above, which will not work when running on OpenShift.
This will manifest as an error in the pod logs similar to the following <code>(node:26) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 127.0.0.1:5432</code></p></div>
<div class="olist arabic"><ol class="arabic"><li><p>To create the appropriate environment variable, run the following command:</p><pre class="highlight listingblock"><code>oc set env dc/nodejs-city-api-server PG_CONNECTION_STRING=postgresql://{user-sanitized-username}:Password1@postgresql.city-of-losangeles.svc:5432/city-info</code></pre></li><li><p>This will trigger a redeploy of your API Server pod.</p></li><li><p>Once this is complete, retry the junction query in the Swagger API.</p></li><li><p>You should now see data returned.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Open your project namespace in the <a href="{openshift-host}/console/project/{walkthrough-namespace}">OpenShift Console</a> and verify that the Node.js deployment was successful.
A single Pod should be running and a route should also be available.
Accessing the route should direct your the OpenAPI Spec docs for your API. Is the route available, and are OpenAPI Docs rendered?</p></div>
<div class="paragraph"><p></p></div>
<h3>Complete the API Implementation</h3><div class="paragraph"><p>You now have a workflow for deploying your Node.js-based API server to the RHMI Cluster. Use this to develop the API endpoints defined in your OpenAPI Spec.</p></div></section></section>
<section><section id="_api_protection_using_3scale_api_management"><h2>API Protection using 3scale API Management</h2><div class="paragraph"><p>In 3scale, we will be dealing with the following constructs:
. An <strong>API</strong> defines the back end service you wish to protect
. An <strong>Applications</strong> define the credentials (e.g. API Key) to access your API. Applications are stored within <strong>Developer Accounts</strong>.
. An <strong>Application Plan</strong> determines the access policies and is always associated with one Application.</p></div><div class="paragraph"><p>In order to secure the traffic and parking meter service that was built in the previous section, we will be performing the following activities in 3scale:
. Creating a new API
. Creating an Application Plan
. Creating an Application
. Configuring the API</p></div><div class="paragraph"><p></p></div></section><section id="_api_management_login"><h2>API Management Login</h2><div class="olist arabic"><ol class="arabic"><li><p>Open the <a href="{api-management-url}" target="_blank">3scale Login screen</a>.</p></li><li><p>Click the <strong>Red Hat Single Sign On</strong> option. This triggers an OAuth Flow and redirects you back to the 3scale API Management Dashboard.</p></li><li><p>Dismiss the <strong>How does 3Scale work?</strong> option which is displayed the first time you log in to 3scale API Management. The main Dashboard is displayed.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Can you see the 3scale API Management Dashboard and navigate the main menu?</p></div>
<div class="paragraph"><p>Verify that you followed each step in the procedure above.  If you are still having issues, contact your administrator.</p></div></section><section id="_creating_a_new_api"><h2>Creating a new API</h2><div class="olist arabic"><ol class="arabic"><li><p>From the <strong>Dashboard</strong>, select the <strong>New API</strong> item.</p></li><li><p>Select the <strong>Define Manually</strong> option.</p></li><li><p>Enter the following as the <strong>Name</strong> and <strong>System name</strong>:</p><pre class="highlight listingblock"><code>{user-sanitized-username}-traffic-service-api</code></pre></li><li><p>Leave the <strong>Description</strong> field empty.</p></li><li><p>Click <strong>Add API</strong> at the bottom of the screen.</p></li></ol></div>
<div class="paragraph"><p></p></div></section><section id="_creating_an_application_plan"><h2>Creating an Application Plan</h2><div class="olist arabic"><ol class="arabic"><li><p>Click <strong>Applications &gt; Application Plans</strong> from the side navigation.</p></li><li><p>Click <strong>Create Application Plan</strong>.</p></li><li><p>Enter the following for <strong>Name</strong> and <strong>System name</strong>:</p><pre class="highlight listingblock"><code>{user-sanitized-username}-traffic-service-plan</code></pre></li><li><p>Leave the other fields with their default values.</p></li><li><p>Select <strong>Create Application Plan</strong>. You will be redirected to the <strong>Application Plans</strong> screen.</p></li><li><p>Select the <strong>Publish</strong> button, beside your plan list item, to publish the Plan.</p></li></ol></div>
<div class="paragraph"><p></p></div></section><section id="_creating_an_application"><h2>Creating an Application</h2><div class="olist arabic"><ol class="arabic"><li><p>Select <strong>Audience</strong> from the top navigation bar dropdown.</p></li><li><p>Select the <strong>Developer</strong> Account to open the <strong>Account Summary</strong> page.</p></li><li><p>Select the <strong>(num) Application</strong> item from the breadcrumb at the top of the screen to view Applications.</p></li><li><p>Click the <strong>Create Application</strong> button in the top right.</p></li><li><p>Select the <strong>{user-sanitized-username}-traffic-service-plan</strong> Plan within the <strong>{user-sanitized-username}-traffic-service-api</strong> section in the <strong>Application plan</strong> dropdown.</p></li><li><p>Enter the following for <strong>Name</strong> and <strong>Description</strong>:</p><pre class="highlight listingblock"><code>{user-sanitized-username}-traffic-service-app</code></pre></li><li><p>Click <strong>Create Application</strong>.</p></li><li><p>Set a custom <strong>User Key</strong> for the application:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>On the <strong>{user-sanitized-username}-traffic-service-app</strong> application screen you were redirected to, scroll to the <strong>API Credentials</strong> section.</p></li><li><p>Click the green pencil icon beside the <strong>API User Key</strong></p></li><li><p>In the <strong>Set Custom User Key</strong> modal dialog, enter:</p><pre class="highlight listingblock"><code>{user-sanitized-username}-traffic-service-key</code></pre></li><li><p>Click <strong>Set Custom Key</strong>.</p></li></ol></div></li></ol></div>
<div class="paragraph"><p></p></div></section><section id="_configuring_the_api"><h2>Configuring the API</h2><div class="olist arabic"><ol class="arabic"><li><p>Click <strong>Integration &gt; Configuration</strong> from the side navigation.</p></li><li><p>Click the <strong>add the base URL of your API and save the configuration.</strong> button.</p></li><li><p>In the <strong>Private Base URL</strong> field, enter the route name that was created for your application in the <strong>API Implementation</strong> section (i.e. when you were coding your Application):</p></li><li><p>Leave the <strong>Staging Public Base URL</strong> with it&#8217;s default value.</p></li><li><p>Click <strong>Update &amp; test in Staging Environment</strong> to save your work.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Do you get a green line down the left had side of the main body of the window - between <strong>API &#8658; API Gateway &#8658; Client</strong>?
Do you also see a message at the bottom of the screen as follows: <strong>onnection between client, gateway &amp; API is working correctly as reflected in the analytics section.</strong></p></div>
<div class="paragraph"><p>Verify that you followed each step in the procedure above.  If you are still having issues, contact your administrator.</p></div></section></section>
<section><section id="_front_end_visualisation_using_react_and_patternfly_4"><h2>Front end visualisation using React and Patternfly 4</h2><div class="paragraph"><p>In this section you will use Patternfly&#8217;s React components to create a web application to display the latest parking meter and junction traffic information.
PatternFly is an open source design system created to enable consistency and usability across a wide range of applications and use cases.</p></div><div class="paragraph"><p>For the Parking Meters page you will:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Display a Google Map</p></li><li><p>Render a map marker for each meter</p></li><li><p>Cluster the meters when the map is zoomed out</p></li><li><p>Support filters for each meter state, e.g show only "available" parking meters</p></li></ol></div><div class="paragraph"><p><br></p></div><div class="paragraph"><p>For the Traffic Junctions page you will:</p></div><div class="olist arabic"><ol class="arabic"><li><p>Display a Google Map</p></li><li><p>Use Heatmap functionality from Google Maps to render traffic conditions</p></li></ol></div><div class="paragraph"><p><br></p></div><div class="paragraph"><p>The end result will look similar to the images below. Here&#8217;s an example of the
Parking Meters being displayed:</p></div><div class="paragraph"><p><br></p></div><div class="imageblock integr8ly-img-responsive" style=""><img src="images/ui-parking-meters.png" alt="ui parking meters"></div><div class="paragraph"><p><br></p></div><div class="paragraph"><p>And here&#8217;s the traffic heatmap built using the junction data</p></div><div class="paragraph"><p><br></p></div><div class="imageblock integr8ly-img-responsive" style=""><img src="images/ui-traffic-heatmap.png" alt="ui traffic heatmap"></div></section><section id="_create_the_ui_github_repository_import_it_into_codeready_workspaces"><h2>Create the UI GitHub Repository &amp; Import it into CodeReady Workspaces</h2><div class="olist arabic"><ol class="arabic"><li><p>Open the UI template repostory on GitHub at <a href="https://github.com/evanshortiss/rhte-2019-hackathon-on-rhmi-template-ui">evanshortiss/rhte-2019-hackathon-on-rhmi-template-ui</a>.</p></li><li><p>Click the green <strong>Use this template</strong> button.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Select an <strong>Owner</strong> organisation and enter a <strong>Repository name</strong>.</p></li><li><p>Click <strong>Create repository from template</strong> button.</p></li></ol></div></li><li><p>Open <a href="{che-url}" target="_blank">CodeReady Workspaces</a>. The <strong>New Workspace</strong> wizard will be displayed.</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Enter a name such as <strong>rhte-hackathon-frontend</strong>.</p></li><li><p>Select <strong>Node10</strong> in the <strong>Select stack</strong> section.</p></li><li><p>In the <strong>Projects</strong> section click <strong>Add or Import Project</strong></p></li><li><p>Choose <strong>GitHub</strong>, and authenticate if necessary by clicking the <strong>Connect your github account</strong> button.</p></li><li><p>Once your accounts and organisations find the repository you created a few moments ago and check the box next to it in the list.</p></li><li><p>Click the blue <strong>Add</strong> button</p></li><li><p>Click the green <strong>Create &amp; Open</strong> button to start the Workspace.</p></li></ol></div></li><li><p>After a minute or two you should be able to see the workspace UI.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Is the CodeReady Workspace loaded with a folder containing your code from GitHub on the left?</p></div>
<div class="paragraph"><p>Try running the steps again. Contact your administrator if it continues to fail.</p></div></section><section id="_running_the_frontend_in_codeready_workspaces"><h2>Running the Frontend in CodeReady Workspaces</h2><div class="olist arabic"><ol class="arabic"><li><p>In the top menu of the CodeReady Workspace UI click the blue <strong>Run</strong> arrow, then click the <strong>newCustom</strong> item that appears in a dropdown.</p></li><li><p>The create command dialog and input fields will be displayed:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Enter <code>Serve</code> in the <strong>Name</strong> field.</p></li><li><p>In the <strong>Command Line</strong> field enter the following command. This will install <code>yarn</code> if it&#8217;s not found then use it to install your dependencies and start the development server:</p><pre class="highlight listingblock"><code>cd ${current.project.path} &amp;&amp; (which yarn || npm i -g yarn) &amp;&amp; yarn &amp;&amp; yarn start:dev</code></pre></li><li><p>Set <strong>Applicable</strong> to <strong>Yes</strong></p></li><li><p>Click the <strong>Macros</strong> above the <strong>Preview URL</strong> field and choose the <code>${server.9000/tcp}</code> option.</p></li><li><p>Click <strong>Save</strong> and wait until the <strong>Manage commands</strong> panel on the left lists your <strong>Serve</strong> command.</p></li></ol></div></li><li><p>Switch back to the source code tree to setup the Google Maps API Key environment variable:</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>In the top menu select <strong>Project &gt; Show/Hide Hidden Files</strong>.</p></li><li><p>Using the top menu again, select <strong>Project &gt; New &gt; File</strong>.</p></li><li><p>Name the file <em>.env</em> when prompted.</p></li><li><p>Open the <em>.env.example</em> file and copy the contents into your new <em>.env</em> file. Ask you administrator for a Google Maps API Key or create a Project on <a href="https://console.developers.google.com/apis/dashboard" target="_blank">Google APIs</a> and create your own API Key.</p></li></ol></div></li><li><p>Run the development server by clicking the blue <strong>Run</strong> arrow again, but this time choosing the newly listed <strong>Serve</strong> option.</p></li><li><p>Wait yarn to install the application dependencies and build, then click the URL printed with the prefix <strong>preview</strong> in the terminal output.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Open your Preview URL from CodeReady Workspaces. You should see a UI with links for Traffic and Parking Maps.</p></div>
<div class="paragraph"><p>Verify no errors are being printed by the Serve command and that your followed each step above correctly. If no map is displayed, but the links are then you need to verify your Google Maps API Key.</p></div></section><section id="_displaying_a_traffic_heatmap"><h2>Displaying a Traffic Heatmap</h2><div class="olist arabic"><ol class="arabic"><li><p>Create a <em>junctions.json</em> file inside the <em>mock-api-server/api-data</em> directory.</p></li><li><p>Paste the following content into the <em>junctions.json</em> file that you created:</p><pre class="highlight listingblock"><code>[
  {
    "junction_id": 2468,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "ALAMEDA  ST AT 6th ST",
    "latitude": 34.0391,
    "longitude": -118.238,
    "count_ns": 28,
    "count_ew": 27
  },
  {
    "junction_id": 341,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "RAMPART BL AT 3RD ST",
    "latitude": 34.0663,
    "longitude": -118.279,
    "count_ns": 17,
    "count_ew": 27
  },
  {
    "junction_id": 3022,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "OLIVE ST S/O 6TH ST",
    "latitude": 34.048,
    "longitude": -118.254,
    "count_ns": 37,
    "count_ew": 12
  },
  {
    "junction_id": 2469,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "OLIVE  ST  AT  4TH  ST",
    "latitude": 34.0516,
    "longitude": -118.251,
    "count_ns": 25,
    "count_ew": 17
  },
  {
    "junction_id": 3183,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "MATEO  ST  AT  6TH  ST",
    "latitude": 34.0384,
    "longitude": -118.233,
    "count_ns": 24,
    "count_ew": 53
  },
  {
    "junction_id": 2479,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "GRAND VIEW ST N/O 6th ST",
    "latitude": 34.0628,
    "longitude": -118.275,
    "count_ns": 60,
    "count_ew": 63
  },
  {
    "junction_id": 1,
    "last_updated": "2019-09-12T20:03:44",
    "junction_name": "CRENSHAW BL AT 36th ST",
    "latitude": 34.0256,
    "longitude": -118.335,
    "count_ns": 40,
    "count_ew": 27
  }
]</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="ulist"><ul><li><p>If you already have an API available you can fill this file with a response from that.</p></li><li><p>This is an incredibly small dataset and will only render a small few spots near Downtown LA.</p></li></ul></div></td></tr></table></div></li><li><p>Open the <em>TrafficMap.tsx</em> file inside the <em>src/app</em> directory.</p></li><li><p>Import the Junction Object type using this code in <em>TrafficMap.tsx</em>:</p><pre class="highlight listingblock"><code>import { JunctionObject } from '@app/ApiInterfaces/api-interfaces';</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="ulist"><ul><li><p>Modify the <code>JunctionObject</code> type in <em>ApiInterfaces/api-interfaces.ts</em> to match structure of your API response if necessary.</p></li></ul></div></td></tr></table></div></li><li><p>Add the following code inside the <code>handleApiLoaded</code> function in <em>TrafficMap.tsx</em>:</p><pre class="highlight listingblock"><code>// Replace with your CodeReady preview URL. Uses the mock api server
const DEV_API_URL = 'https://CODE_READY_PREVIEW_URL/junctions'
// Replace with your 3scale API url
const LIVE_API_URL = 'https://YOUR_LIVE_API_URL/junctions'

const request = await fetch(DEV_API_URL)
const junctions: JunctionObject[] = await request.json()

new google.maps.visualization.HeatmapLayer({
  data: junctions.map(j =&gt; {
    return {
      location: new google.maps.LatLng(j.latitude, j.longitude),
      weight: j.count_ns + j.count_ew
    }
  }),
  map: map,
  radius: 10
})</code></pre></li><li><p>Ensure all files are saved and restart the <strong>Serve</strong> command.</p></li></ol></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Open your Preview URL from CodeReady Workspaces and navigate to the Traffic Map UI. You should see some heatmap spots near Downtown LA.</p></div>
<div class="paragraph"><p>Open your browser&#8217;s DevTools, e.g in Chrome use Command+Option+I on macOS, or F12 or Control+Shift+I in Windows and Linux. Check for errors in the JavaScript Console and Network Console. The XHR request to /junctions should be successful and no Google Maps API errors should be listed.</p></div></section><section id="_displaying_parking_meters"><h2>Displaying Parking Meters</h2><div class="paragraph"><p>Use a similar workflow as you did for the heatmap to display markers for
parking meters. Some hints are provided in the <em>ParkingMap.tsx</em> file to help
you get started.</p></div></section></section></div></div><script src="node_modules/reveal.js/lib/js/head.min.js"></script><script src="node_modules/reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'node_modules/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'node_modules/reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>